class Solution:
    def maxProfit(self, n: int, present: List[int], future: List[int], hierarchy: List[List[int]], budget: int) -> int:
        from functools import lru_cache
        import math
        tree = [[] for _ in range(n)]
        for u, v in hierarchy:
            tree[u - 1].append(v - 1)
        def merge(a, b):
            res = [-math.inf] * (budget + 1)
            for i in range(budget + 1):
                if a[i] < 0:
                    continue
                for j in range(budget + 1 - i):
                    if b[j] < 0:
                        continue
                    res[i + j] = max(res[i + j], a[i] + b[j])
            return res
        @lru_cache(None)
        def dfs(u):
            dp0 = [0] + [-math.inf] * budget
            dp1 = [0] + [-math.inf] * budget
            for v in tree[u]:
                c0, c1 = dfs(v)
                dp0 = merge(dp0, c0)
                dp1 = merge(dp1, c1)
            res0 = dp0[:]
            res1 = dp0[:]
            full_cost = present[u]
            full_profit = future[u] - full_cost
            for b in range(full_cost, budget + 1):
                if dp1[b - full_cost] >= 0:
                    res0[b] = max(res0[b], dp1[b - full_cost] + full_profit)
            half_cost = present[u] // 2
            half_profit = future[u] - half_cost
            for b in range(half_cost, budget + 1):
                if dp1[b - half_cost] >= 0:
                    res1[b] = max(res1[b], dp1[b - half_cost] + half_profit)
            return res0, res1
        return max(dfs(0)[0])
